statement ok
CREATE TABLE t (a INT, b INT, c FLOAT, d INT PRIMARY KEY);

statement ok
INSERT INTO t VALUES (1,1,1.0,1), (1,2,2.0,2), (2,2,3.0,3);

query II rowsort
SELECT a, count(b) OVER (PARTITION BY a) FROM t;
----
1
2
1
2
2
1

query II rowsort
SELECT a, count(b) OVER (PARTITION BY a) FROM t WHERE b = 2;
----
1
1
2
1

query II rowsort
SELECT a, count(b) OVER (PARTITION BY a) FROM t WHERE b = 2 AND a = 1;
----
1
1

onlyif readyset
statement error: Aggregates in window functions
SELECT a, count(*) OVER (PARTITION BY sum(a)) FROM t;

onlyif readyset
statement error: Mixing window functions and aggregates
SELECT a, count(*) OVER (PARTITION BY a) FROM t GROUP BY a;

query II rowsort
SELECT a, count(*) OVER() FROM t;
----
1
3
1
3
2
3

query II rowsort
SELECT a, count(c) OVER() FROM t WHERE b = 2;
----
1
2
2
2

query III
SELECT a, b, row_number() OVER (PARTITION BY a) FROM t;
----
1
1
1
1
2
2
2
2
1

query II rowsort
SELECT a, sum(b) OVER (PARTITION BY a) FROM t;
----
1
3
1
3
2
2

query IR rowsort
SELECT a, avg(b) OVER (PARTITION BY a) FROM t;
----
1
1.5
1
1.5
2
2.0

query II rowsort
SELECT d, rank() OVER (PARTITION BY a) FROM t;
----
1
1
2
1
3
1

query II rowsort
SELECT d, dense_rank() OVER (PARTITION BY a) FROM t;
----
1
1
2
1
3
1

query II rowsort
SELECT d, max(b) OVER () FROM t;
----
1
2
2
2
3
2

# test deletions and insertions

statement ok
INSERT INTO t VALUES (1,3,4.0,4);

statement ok
DELETE FROM t WHERE d = 1;

# Test cumulative AVG
query IR rowsort
SELECT a, avg(b) OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
2.0
1
2.5
2
2.0

query IR rowsort
SELECT a, avg(c) OVER (PARTITION BY a ORDER BY c) FROM t;
----
1
2.0
1
3.0
2
3.0

# Test cumulative MIN
query II rowsort
SELECT a, min(b) OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
2
1
2
2
2

query IR rowsort
SELECT a, min(c) OVER (PARTITION BY a ORDER BY c) FROM t;
----
1
2.0
1
2.0
2
3.0

# Test cumulative MAX
query II rowsort
SELECT a, max(b) OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
2
1
3
2
2

query IR rowsort
SELECT a, max(c) OVER (PARTITION BY a ORDER BY c) FROM t;
----
1
2.0
1
4.0
2
3.0

# Test cumulative ROW_NUMBER
query II rowsort
SELECT a, row_number() OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
1
1
2
2
1

query II rowsort
SELECT a, row_number() OVER (PARTITION BY a ORDER BY c) FROM t;
----
1
1
1
2
2
1

# Test cumulative RANK
query II rowsort
SELECT a, rank() OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
1
1
2
2
1

query II rowsort
SELECT a, rank() OVER (PARTITION BY a ORDER BY c) FROM t;
----
1
1
1
2
2
1

# Test cumulative DENSE_RANK
query II rowsort
SELECT a, dense_rank() OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
1
1
2
2
1

query II rowsort
SELECT a, dense_rank() OVER (PARTITION BY a ORDER BY c) FROM t;
----
1
1
1
2
2
1

# Test with multiple ORDER BY columns
query II rowsort
SELECT a, sum(b) OVER (PARTITION BY a ORDER BY b, c) FROM t;
----
1
2
1
5
2
2

# Test with DESC ordering
query II rowsort
SELECT a, sum(b) OVER (PARTITION BY a ORDER BY b DESC) FROM t;
----
1
3
1
5
2
2

query II rowsort
SELECT a, row_number() OVER (PARTITION BY a ORDER BY b DESC) FROM t;
----
1
1
1
2
2
1

# Test with ties in ORDER BY (same values should get same rank)
statement ok
INSERT INTO t VALUES (1,2,5.0,5), (2,2,6.0,6);

query II rowsort
SELECT a, rank() OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
1
1
1
1
3
2
1
2
1

query II rowsort
SELECT a, dense_rank() OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
1
1
1
1
2
2
1
2
1

# Test cumulative functions with no partition (over entire table)

query II rowsort
SELECT a, sum(b) OVER (ORDER BY a) FROM t;
----
1
7
1
7
1
7
2
11
2
11

query II rowsort
SELECT a, count(*) OVER (ORDER BY a) FROM t;
----
1
3
1
3
1
3
2
5
2
5

query II rowsort
SELECT a, row_number() OVER (ORDER BY a, b) FROM t;
----
1
1
1
2
1
3
2
4
2
5

# Test edge cases: empty partitions
# remove all rows with a = 2
statement ok
DELETE FROM t WHERE d = 3;

statement ok
DELETE FROM t WHERE d = 6;

query II rowsort
SELECT a, sum(b) OVER (PARTITION BY a ORDER BY b) FROM t;
----
1
4
1
4
1
7

# Test rank with multiple ORDER BY columns
query II rowsort
SELECT a, rank() OVER (PARTITION BY a ORDER BY b, c) FROM t;
----
1
1
1
2
1
3

# Test rank with DESC ordering
query II rowsort
SELECT a, rank() OVER (PARTITION BY a ORDER BY b DESC) FROM t;
----
1
1
1
2
1
2

statement ok
INSERT INTO t VALUES (2,2,6.0,6);

# Test rank over entire table (no partition)
query II rowsort
SELECT a, rank() OVER (ORDER BY a, b) FROM t;
----
1
1
1
1
1
3
2
4

# Test dense_rank over entire table (no partition)
query II rowsort
SELECT a, dense_rank() OVER (ORDER BY a, b) FROM t;
----
1
1
1
1
1
2
2
3

# Edge case: Empty table
statement ok
CREATE TABLE t_empty (a INT, b INT);

query II
SELECT a, sum(b) OVER (PARTITION BY a) FROM t_empty;
----

# Edge case: Single row table
statement ok
CREATE TABLE t_single (a INT, b INT);

statement ok
INSERT INTO t_single VALUES (42, 100);

query II
SELECT a, sum(b) OVER (PARTITION BY a) FROM t_single;
----
42
100

# Edge case: All rows in one partition
statement ok
CREATE TABLE t_onepart (a INT, b INT);

statement ok
INSERT INTO t_onepart VALUES (1, 10), (1, 20), (1, 30);

query II rowsort
SELECT a, sum(b) OVER (PARTITION BY a) FROM t_onepart;
----
1
60
1
60
1
60

# Edge case: All unique partitions
statement ok
CREATE TABLE t_uniquepart (a INT, b INT);

statement ok
INSERT INTO t_uniquepart VALUES (1, 10), (2, 20), (3, 30);

query II rowsort
SELECT a, sum(b) OVER (PARTITION BY a) FROM t_uniquepart;
----
1
10
2
20
3
30

# Edge case: All same ORDER BY value
statement ok
CREATE TABLE t_sameorder (a INT, b INT);

statement ok
INSERT INTO t_sameorder VALUES (1, 5), (2, 5), (3, 5);

query II rowsort
SELECT a, row_number() OVER (ORDER BY b) FROM t_sameorder;
----
1
1
2
2
3
3

# Edge case: Negative, zero, large values
statement ok
CREATE TABLE t_negzero (a INT, b INT);

statement ok
INSERT INTO t_negzero VALUES (-1, -100), (0, 0), (999999, 1000000000);

query II rowsort
SELECT a, sum(b) OVER (ORDER BY a) FROM t_negzero;
----
-1
-100
0
-100
999999
999999900

# Test window functions in subqueries

query II rowsort
SELECT a, b FROM t WHERE a IN (SELECT a FROM (SELECT a, row_number() OVER (ORDER BY a) as rn FROM t) sq WHERE rn <= 2);
----
1
2
1
2
1
3

# Test unsupported positions for window functions

onlyif readyset
statement error: Window functions are not allowed in WHERE clauses
SELECT a, row_number() OVER (ORDER BY a) as rn FROM t WHERE row_number() OVER (ORDER BY a) > 1;

onlyif readyset
statement error: Window functions are not allowed in WHERE clauses
SELECT a, b FROM t WHERE CASE WHEN row_number() OVER (ORDER BY a) > 1 THEN 1 ELSE 0 END = 1;

onlyif readyset
statement error: Window functions are not allowed in WHERE clauses
SELECT a, b FROM t WHERE abs(row_number() OVER (ORDER BY a)) > 1;

onlyif readyset
statement error: Window functions are not allowed in GROUP BY clauses
SELECT a, count(*) as cnt FROM t GROUP BY row_number() OVER (ORDER BY a);

onlyif readyset
statement error: Window functions are not allowed in GROUP BY clauses
SELECT a, count(*) as cnt FROM t GROUP BY (row_number() OVER (ORDER BY a) + 1);

onlyif readyset
statement error: Window functions in ORDER BY clauses are not supported
SELECT a, b FROM t ORDER BY row_number() OVER (ORDER BY a);

onlyif readyset
statement error: Window functions in ORDER BY clauses are not supported
SELECT a, b FROM t ORDER BY SUM(b) OVER (PARTITION BY a) DESC;

onlyif readyset
statement error: Window functions are not allowed in HAVING clauses
SELECT a, count(*) as cnt FROM t GROUP BY a HAVING (count(*) OVER (PARTITION BY a) * 2) > 4;

onlyif readyset
statement error: Window functions are not allowed in HAVING clauses
SELECT a, count(*) as cnt FROM t GROUP BY a HAVING row_number() OVER (ORDER BY a) > 1;

onlyif readyset
statement error: Window functions are not allowed in HAVING clauses
SELECT a, count(*) as cnt FROM t GROUP BY a HAVING CASE WHEN count(*) OVER (PARTITION BY a) > 1 THEN 1 ELSE 0 END = 1;

onlyif readyset
statement error: Window functions are not allowed in HAVING clauses
SELECT a, count(*) as cnt FROM t GROUP BY a HAVING abs(count(*) OVER (PARTITION BY a)) > 1;

onlyif readyset
statement error: Window functions are not allowed in JOIN ON conditions
SELECT t1.a, t2.b FROM t t1 JOIN t t2 ON t1.a = t2.a AND row_number() OVER (ORDER BY t1.b) > 1;

onlyif readyset
statement error: Window functions are not allowed in JOIN ON conditions
SELECT t1.a, t2.b FROM t t1 LEFT JOIN t t2 ON count(*) OVER (PARTITION BY t1.a) = t2.b;

onlyif readyset
statement error: Window functions are not allowed in JOIN ON conditions
SELECT t1.a, t2.b FROM t t1 INNER JOIN t t2 ON sum(t1.b) OVER (PARTITION BY t1.a) > t2.b;

# Test that nested window functions are not allowed

onlyif readyset
statement error: Window functions cannot contain nested window functions
SELECT a, row_number() OVER (PARTITION BY row_number() OVER (ORDER BY a)) FROM t;

onlyif readyset
statement error: Window functions cannot contain nested window functions
SELECT a, sum(b) OVER (ORDER BY row_number() OVER (ORDER BY a)) FROM t;

onlyif readyset
statement error: Window functions cannot contain nested window functions
SELECT a, count(*) OVER (PARTITION BY a ORDER BY sum(b) OVER (PARTITION BY a)) FROM t;

onlyif readyset
statement error: Window functions cannot contain nested window functions
SELECT a, rank() OVER (ORDER BY rank() OVER (ORDER BY b)) FROM t;

# post-lookups (ranges, betweens, WHERE .. IN ..)

onlyif readyset
statement error: Post-lookups are not supported for window functions
SELECT a, sum(b) OVER (PARTITION BY a) FROM t WHERE a >= 1 AND a <= 3;

onlyif readyset
statement error: Post-lookups are not supported for window functions
SELECT a, sum(b) OVER (PARTITION BY a) FROM t WHERE a > 1 AND a < 3;

# the autoparameterization pass doesn't parametrize the between
# this should error once the between is actually parametrized
# statement error: Post-lookups are not supported for window functions
# SELECT a, sum(b) OVER (PARTITION BY a) FROM t WHERE a BETWEEN 1 AND 3;

onlyif readyset
statement error: Post-lookups are not supported for window functions
SELECT a, sum(b) OVER (PARTITION BY a) FROM t WHERE a IN (1, 2, 3);

# distinct not supported in WFs (yet)

onlyif readyset
statement error: Query failed to parse
SELECT COUNT(DISTINCT a) OVER () FROM t;

onlyif readyset
statement error: Query failed to parse
SELECT SUM(DISTINCT a) OVER (PARTITION BY a) FROM t;

onlyif readyset
statement error: Query failed to parse
SELECT AVG(DISTINCT a) OVER (PARTITION BY a) FROM t;

onlyif readyset
statement error: Window name in Window Spec
SELECT a, sum(b) OVER (w) FROM t WINDOW w AS (PARTITION BY a);

onlyif readyset
statement error: Window frame in Window Spec
SELECT a, sum(b) OVER (PARTITION BY a ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM t;

onlyif readyset
statement error: Using multiple window functions is not yet supported
SELECT a, sum(b) OVER (PARTITION BY a), avg(b) OVER (PARTITION BY a) FROM t;
