statement ok
create table dogs (id int, name text);

statement ok
insert into dogs values
  (1, 'kidnap'),
  (2, 'snoopy');

statement ok
create table tags (d_id int, tag text);

statement ok
insert into tags values
  (1, 'bbb'),
  (1, 'aaa'),
  (1, 'ccc'),
  (2, 'yyy'),
  (2, 'zzz');


# simple query (no NULLs in data)
query T
select array_agg(t.tag) from tags t where d_id = 1;
----
{bbb,aaa,ccc}

statement ok
insert into tags values (1, 'bbb');

# simple query (no NULLs in data)
query T
select array_agg(t.tag) from tags t where d_id = 1;
----
{bbb,aaa,ccc,bbb}


# simple query (with NULLs in data)
# Note: array_agg() _does_ include nulls in the output
statement ok
insert into tags values
  (1, NULL),
  (1, 'aaa');

query T
select array_agg(t.tag) from tags t where d_id = 1;
----
{bbb,aaa,ccc,bbb,NULL,aaa}

# simple query (with NULLs and dupes!)
query T
select array_agg(distinct t.tag) from tags t where d_id = 1;
----
{NULL,aaa,bbb,ccc}


# multiple aggregations
query IT
select sum(d_id), array_agg(t.tag) from tags t where d_id = 1;
----
6
{bbb,aaa,ccc,bbb,NULL,aaa}


# join and group by clause
query ITT
select d.id, d.name, array_agg(t.tag) as tag_arr
  from dogs as d
  left join tags as t on d.id = t.d_id
  where d.id = 1
  group by d.id, d.name;
----
1
kidnap
{bbb,aaa,ccc,bbb,NULL,aaa}


# add in an extra NULL, for fun (for testing distinct in the order by clauses)
statement ok
insert into tags values
  (1, NULL);

query T
select array_agg(t.tag) from tags t where d_id = 1;
----
{bbb,aaa,ccc,bbb,NULL,aaa,NULL}


#####
## order by ASC testing
####

# order by asc 
query T
select array_agg(t.tag order by tag) from tags t where d_id = 1;
----
{aaa,aaa,bbb,bbb,ccc,NULL,NULL}

# order by asc, NULLs first
query T
select array_agg(t.tag order by tag nulls first) from tags t where d_id = 1;
----
{NULL,NULL,aaa,aaa,bbb,bbb,ccc}

# order by asc, NULLs last
query T
select array_agg(t.tag order by tag nulls last) from tags t where d_id = 1;
----
{aaa,aaa,bbb,bbb,ccc,NULL,NULL}


# order by asc with distinct
query T
select array_agg(distinct t.tag order by tag) from tags t where d_id = 1;
----
{aaa,bbb,ccc,NULL}

# order by asc, NULLs first, with distinct
query T
select array_agg(distinct t.tag order by tag nulls first) from tags t where d_id = 1;
----
{NULL,aaa,bbb,ccc}

# order by asc, NULLs last, with distinct
query T
select array_agg(distinct t.tag order by tag nulls last) from tags t where d_id = 1;
----
{aaa,bbb,ccc,NULL}


#####
## order by DESC testing
####

# order by desc 
query T
select array_agg(t.tag order by tag desc) from tags t where d_id = 1;
----
{NULL,NULL,ccc,bbb,bbb,aaa,aaa}

# order by desc, NULLs first
query T
select array_agg(t.tag order by tag desc nulls first) from tags t where d_id = 1;
----
{NULL,NULL,ccc,bbb,bbb,aaa,aaa}

# order by desc, NULLs last
query T
select array_agg(t.tag order by tag desc nulls last) from tags t where d_id = 1;
----
{ccc,bbb,bbb,aaa,aaa,NULL,NULL}


# order by desc with distinct
query T
select array_agg(distinct t.tag order by tag desc) from tags t where d_id = 1;
----
{NULL,ccc,bbb,aaa}

# order by desc, NULLs first, with distinct
query T
select array_agg(distinct t.tag order by tag desc nulls first) from tags t where d_id = 1;
----
{NULL,ccc,bbb,aaa}

# order by desc, NULLs last, with distinct
query T
select array_agg(distinct t.tag order by tag desc nulls last) from tags t where d_id = 1;
----
{ccc,bbb,aaa,NULL}


#######
# test only empty/NULL inputs

# empty results
query
select array_agg(tag) from tags where d_id = 3;
----
NULL

statement ok
insert into tags values
  (3, NULL);

# only NULL rows
query
select array_agg(tag) from tags where d_id = 3;
----
{NULL}


#####
# post-lookup aggregations

query T
select array_agg(t.tag) from tags t where d_id in (1, 2);
----
{bbb,aaa,ccc,bbb,NULL,aaa,NULL,yyy,zzz}

# distinct, but add in a value for id 2 that overlaps with id 1'd values
statement ok
insert into tags values (2, 'AAA');

query T
select array_agg(distinct t.tag) from tags t where d_id in (1, 2);
----
{NULL,aaa,AAA,bbb,ccc,yyy,zzz}

# order by
query T
select array_agg(t.tag order by tag desc) from tags t where d_id in (1, 2);
----
{NULL,NULL,zzz,yyy,ccc,bbb,bbb,AAA,aaa,aaa}

query T
select array_agg(t.tag order by tag desc nulls first) from tags t where d_id in (1, 2);
----
{NULL,NULL,zzz,yyy,ccc,bbb,bbb,AAA,aaa,aaa}

query T
select array_agg(t.tag order by tag asc nulls last) from tags t where d_id in (1, 2);
----
{aaa,aaa,AAA,bbb,bbb,ccc,yyy,zzz,NULL,NULL}

# empty results
query
select array_agg(tag) from tags where d_id in (12345, 23456);
----
NULL

statement ok
insert into tags values
  (12345, NULL);

# only NULL rows
query
select array_agg(tag) from tags where d_id in (12345, 23456);
----
{NULL}

statement ok
insert into tags values
  (23456, NULL);

# only NULL rows
query
select array_agg(tag) from tags where d_id in (12345, 23456);
----
{NULL,NULL}


#####
# test expressions in aggregate arguments

# test with function expression (upper)
query T
select array_agg(upper(t.tag)) from tags t where d_id = 1;
----
{BBB,AAA,CCC,BBB,NULL,AAA,NULL}

# test with function expression (upper) - post-lookup aggregation
query T
select array_agg(upper(t.tag)) from tags t where d_id in (1, 2);
----
{BBB,AAA,CCC,BBB,NULL,AAA,NULL,YYY,ZZZ,AAA}

# test with binary operation (arithmetic)
statement ok
create table nums (id int, val int);

statement ok
insert into nums values (1, 10), (1, 20), (1, 30);

query T
select array_agg(val + 5) from nums where id = 1;
----
{15,25,35}

query T
select array_agg(val * 2) from nums where id = 1;
----
{20,40,60}

# test with binary operation (arithmetic) - post-lookup aggregation
statement ok
insert into nums values (2, 100), (2, 200);

query T
select array_agg(val + 5) from nums where id in (1, 2);
----
{15,25,35,105,205}

# test with string concatenation function
query T
select array_agg(concat(t.tag, '-suffix')) from tags t where d_id = 2;
----
{yyy-suffix,zzz-suffix,AAA-suffix}

# test with string concatenation function - post-lookup aggregation
query T
select array_agg(concat(t.tag, '-suffix')) from tags t where d_id in (1, 2);
----
{bbb-suffix,aaa-suffix,ccc-suffix,bbb-suffix,NULL,aaa-suffix,NULL,yyy-suffix,zzz-suffix,AAA-suffix}


#####
# test with CAST in aggregate argument (REA-6285)
# The cast must be preserved in the cache definition so that PostgreSQL
# can resolve the function overload correctly.

# column cast
query T
select array_agg(t.tag::text) from tags t where d_id = 2;
----
{yyy,zzz,AAA}

# column cast - post-lookup aggregation
query T
select array_agg(t.tag::text) from tags t where d_id in (1, 2);
----
{bbb,aaa,ccc,bbb,NULL,aaa,NULL,yyy,zzz,AAA}

# literal cast inside aggregate (the actual REA-6285 failure mode)
# A literal like 'hello'::text would previously be constant-folded away,
# stripping the cast and causing a cache-definition mismatch with PostgreSQL.
query T
select array_agg('hello'::text) from tags t where d_id = 2;
----
{hello,hello,hello}

# literal cast inside aggregate - post-lookup aggregation
query T
select array_agg('hello'::text) from tags t where d_id in (1, 2);
----
{hello,hello,hello,hello,hello,hello,hello,hello,hello,hello}
