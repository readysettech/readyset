# Git

ReadySet uses the so-called [stacked diff][] approach which this document
explores in detail.

[stacked diff]: https://jg.gg/2018/09/29/stacked-diffs-versus-pull-requests/

## Git's Model

It is helpful to have a better understanding of Git's model when working
in the stacked diff model since it involves history rewriting operations.

One of the references for this is [Git from the Bottom Up][0] by John Wiegley.

[0]: https://jwiegley.github.io/git-from-the-bottom-up/

## Commits

Commits should be conceptually distinct unit of changes made to the code base.
Code review is done on commits. There are no merge commits resulting in a single
linear history.

In order to help with this, commits are worked on via these history rewriting
commands, like rebasing, more often.

### Messages

An example git commit mesasge looks like the following:

```text
Capitalized, short (50 chars or less) summary

More detailed explanatory text, if necessary.  Wrap it to about 72
characters or so. In some contexts, the first line is treated as the
subject of an email and the rest of the text as the body. The blank
line separating the summary from the body is critical the body entirely;
tools like rebase can get confused if you run the two together.

Write your commit message in the imperative mood: "Fix bug" and not
"Fixed bug" or "Fixes bug." This convention matches up with commit
messages generated by commands like git merge and git revert.

Further paragraphs come after blank lines.

- Bullet points are okay

- Typically a hyphen or asterisk is used for the bullet followed by a
  single space, with blank lines in between, but conventions vary here

- Use a hanging indent

Fixes: ENG-1234
Change-Id: Iffffffffffffffffffffffffffffffffff
```

(Above from [A Note About Git Commit Messages][1] by Tim Pope with some edits).

[1]: https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html

This commit message is also the primary message associated with code review.

To help with writing the above, here are some helpful settings for different
editors:

## Rebasing

Interactive rebasing contains a number of tools and the [documentation][2] for
interactive rebase includes a couple of common examples of splitting and
merging commits together.

[2]: https://git-scm.com/docs/git-rebase#_interactive_mode

### Modifying the HEAD commit

If you are working against the current HEAD commit only, `git commit --amend`
will modify that commit without having to go through rebase.

If you also don't want to rewrite the commit message at this time
`git commit --amend --no-edit` will change the commit without asking to modify
the commit message.

### Autosquash

When making commits, you can use `git commit --fixup` and `git commit --squash`
to label a commit in progress with what commit it should be fixed-up or squashed
into during a rebase. This requires running interactive rebase with the
`--autosquash` option or configuring this to be the default behavior by running
`git config --global rebase.autosquash true`.

Thoughtbot has [written more][3] about using this feature of git.

[3]: https://thoughtbot.com/blog/autosquashing-git-commits
