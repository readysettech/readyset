# Pagination

This page documents the way ReadySet currently implements *pagination* in
queries, and explains some of the caveats and limitations with our
implementation.

Within SQL, "pagination" refers to a combination of the `ORDER BY`, `LIMIT`, and
`OFFSET` clauses. Currently, ReadySet is focused on running queries where the
`LIMIT` is constant (not parametrized) but the `OFFSET` *is* parametrized, and
where the value for the `OFFSET` parameter is always an integer multiple of the
`LIMIT`. This corresponds to a "page number" field on a regular web page.

For the sake of a consistent example, let's consider the following DDL and query
throughout this page:

```sql
CREATE TABLE posts (
    id INT PRIMARY KEY,
    title TEXT NOT NULL,
    author_id INT NOT NULL,
    score INT NOT NULL,
);

SELECT id, title, score
FROM posts
WHERE author_id = ?
ORDER BY score DESC
LIMIT 10
OFFSET ?
```

## The `Paginate` operator

The core of the implementation of pagination in ReadySet is the [`Paginate`
operator][paginate]. This operator groups its input by a [set of
columns][group_by] (the parameters in the query, currently), then for each group
sorts all the records in that group by [another set of columns][order] (along
with `ASC`ending or `DESC`ending for each column), then projects out a new *page
number* column for each page within that ordered group, with a page size
specified by a configurable [limit][]. We then use that page number column as
one of the parameters in the reader node created for the query, translating the
value provided for the `OFFSET` by the user into a page number by dividing it by
the limit.

For example, the above query would be compiled to the following dataflow graph:

![paginate example graph](/images/paginate-example.png)

[paginate]: http://docs/rustdoc/noria_dataflow/ops/paginate/struct.Paginate.html
[`limit`]: http://docs/rustdoc/noria_dataflow/ops/paginate/struct.Paginate.html#structfield.limit
[group_by]: http://docs/rustdoc/noria_dataflow/ops/paginate/struct.Paginate.html#structfield.group_by
[order]: http://docs/rustdoc/noria_dataflow/ops/paginate/struct.Paginate.html#structfield.order

### Making pagination partial

Making the `Paginate` operator partial in any way is a little tricky, since we
parametrize the query by the `page_number` column, which is generated by the
`Paginate` node (it doesn't trace back verbatim to the node's parent).
Fortunately, however, we have a little bit of a trick we can pull - since the
page number is local to the rows within a particular group, we can consider the
page number column ["generated"][] from the group columns, and [*remap* all
upqueries][upquery-remapping] to keys with both the group columns and the page
columns into upqueries for just the group. This means we end up materializing
*all* records for the group into the node, which isn't *ideal* (we'd rather only
materialize one page at a time), but is better than being fully materialized. We
call this situation **partial-per-group pagination**, since we're only partial at
the granularity of a single group of the operator, and the ideal future
situation **partial-per-page pagination**.

["generated"]: http://docs/rustdoc/noria_dataflow/prelude/enum.ColumnSource.html#variant.GeneratedFromColumns
[upquery-remapping]: ./replay_paths.md#generated-columns-but-remapped
